# Inner layer of encryption
Generally, this inner encryption process uses a static server key, and generates new client keypair to agree on a static Diffie-Hellman shared secret for each new request. The shared secret is HKDF'ed and any data is encrypted with AES-GCM and sent alongside the generated client public key so the server can calculate the shared secret.

However, if the user is logged-in, WeChat receives a session key from the server that is used for encryption instead. In addition, when logged in, after receiving this session key, future encryption is mostly done using AES-CBC instead of AES-GCM.

To differentiate between these two combined cryptosystems, we refer to the initial static ECDH + AES-GCM system as the Inner AES-GCM encryption and the subsequent AES-CBC system as the Inner AES-CBC encryption.

## Inner AES-GCM

For this section, we did dynamic and static analysis of routines in `libwechatmm.so`; in particular the `HybridEcdhEncrypt` and `HybridEcdhDecrypt` functions, which call `AesGcmEncryptWithCompress` / `AesGcmDecryptWithUncompress`, respectively.

### Key generation
For each request, the client generates a public, private keypair for use with ECDH. We also note that the client has a `static server public key` pinned in the application.

The client then calculates an `initial secret key`, and a derived key via HKDF.
```
	inital_secret = ECDH(static_server_pub, client_priv)
	hash = sha256(client_pub)
	client_random = <32 randomly generated bytes>
	derived_key = HKDF(initial_secret, salt=hash|client_random,
                      ”security hkdf key expand”, 32)
```
If the client is logged-out, the `derived_key` is then used to encrypt the data.

When logged-in, there is only one initial authentication request encrypted to WeChat servers using this AES-GCM routine. If the user logs in, this request is referred to as `manualauth` in the code. If the user is already logged in and starts up the application, this request is referred to as `autoauth`.

Once the `auth` response is received, future requests are mostly encrypted using AES-CBC by default, though some larger files are still encrypted using AES-GCM.


### Auth request

The initial packets are encrypted using the key material above. If the client is logged in, the first request will be a very large data packet authenticating the user to the server (referred to as autoauth in WeChat internals) which also contains key material. In addition, the client pulls a locally-stored key `autoauth_key`.

An abbreviated version of the autoauth packet:
	
	08 01 12 . . . [Header metadata]
	04 46 40 96 4d 3e 3e 7e [Client public key] . . .
	fa 5a 7d a7 78 e1 ce 10 . . . [ClientRandom encrypted w initial_secret]
	a1 fb 0c da . . .               	[IV]
	9e bc 92 8a 5b 81 . . . 	    	[tag]
	db 10 d3 0f f8 e9 a6 40 . . . [ClientRandom encrypted w autoauth_key]
	75 b4 55 30 . . .			[IV]
	d7 be 7e 33 a3 45 . . . 		[tag]
	c1 98 87 13 eb 6f f3 20 . . . [plaintext encrypted w derived_key]
	4c ca 86 03 . . 				[IV]
	3c bc 27 4f 0e 7b . . . 		[tag]

This repository contains a full sample of the `autoauth` request at each layer of encryption, including the [Outer encryption-wrapped record](../crack/data/autoauth-request-packet.hex), [Inner encryption-wrapped record](../crack/data/autoauth-request-inner-ciphertext.hex), and [plaintext Protobuf](../crack/data/autoauth-request.json).

The client encrypts here using AES-GCM with a randomly generated IV, and uses a SHA256 hash of the preceding message contents as AAD. At this stage, the messages (including the ClientRandom messages) are always ZLib compressed before encryption.

	iv = <12 random bytes>
	compressed = zlib_compress(plaintext)
	ciphertext, tag = AES-GCM(compressed, aad = hash(previous), key, iv)

The client appends the 12-byte IV, then the 16-byte tag, onto the ciphertext. This tag can be used by the server to verify the integrity of the ciphertext, and essentially functions as a MAC. 

### Auth Response
The response to autoauth is serialized similarly to the request:

	08 01 12 . . . [Header metadata]
	04 46 40 96 4d 3e 3e 7e [Server public key] . . .
	c1 98 87 13 eb 6f f3 20 . . . [plaintext encrypted w new_secret]
	4c ca 86 03 . . 				[IV]
	3c bc 27 4f 0e 7b . . . 		[tag]

With the newly received server public key, the client then derives a new secret.

	new_secret = ECDH(server_pub, client_priv)
	autoauth_response = AES-GCM(aad = hash(previous), new_secret, iv)

The client can also verify the response with the given `tag`. The `autoauth_response` is a serialized Protobuf containing a lot of important data for WeChat to start, starting with a helpful `Everything is ok ` status message. A full sample of this Protobuf can be found [here](../crack/data/autoauth-response.json), as well as the [inner-encrypted response](../crack/data/autoauth-response-inner-ciphertext.hex) and the [outer-encrypted response](../crack/data/autoauth-response-packet.hex).

Most importantly, there is one field in particular, the inner `session_key` that will be used for future encryption and decryption. `new_secret` is also used here.

#### Note
The MMTLS code refers to three different keys: client_session, server_session, and single_session. Generally, client_session refers to the client_public key, server_session refers to the shared secret key generated using ECDH, and single_session refers to this inner session key provided by the server. 

## Inner AES-CBC

The encryption process for requests after key establishment is straightforward. The Inner Encryption uses AES-CBC with PKCS-7 padding, with the inner session key as a symmetric key:

	ciphertext = AES-CBC(PKCS7_pad(plaintext))

Generally, plaintext is a serialized Protobuf, optionally compressed with Zlib.
This inner session key is also used as the IV for encryption.

## Integrity check
Finally, a function called genSignature calculates a pseudo-integrity code on the plaintext. This function first calculates the MD5 hash of the plaintext, keyed with server_session. The function uses Adler32, a checksumming function, on the MD5 hash concatenated with the plaintext. The result from Adler32 is used as the “integrity code” of the plaintext, and concatenated to the ciphertext as metadata.


